// This file is automatically generated. Do not edit it directly.
import { createClient, type Session, type User } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

const isProcessAvailable = typeof process !== 'undefined';
const isTestLikeEnv = isProcessAvailable && (
  process.env.VITEST ||
  process.env.NODE_ENV === 'test' ||
  process.env.CI
);
const isMockFlagEnabled = import.meta.env.VITE_USE_MOCK_SUPABASE === 'true';

// When running in CI/tests or without real credentials we force a deterministic mock client
const shouldForceMockSupabase = isTestLikeEnv || isMockFlagEnabled;

// Enhanced validation: detect missing AND placeholder values
function validateSupabaseConfig(): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];

  // Check if variables exist
  if (!SUPABASE_URL) {
    errors.push('VITE_SUPABASE_URL is not set');
  }
  if (!SUPABASE_ANON_KEY) {
    errors.push('VITE_SUPABASE_ANON_KEY is not set');
  }

  // Check for placeholder/dummy values
  if (SUPABASE_URL && (
    SUPABASE_URL.includes('your-project') ||
    SUPABASE_URL === 'https://your-project.supabase.co' ||
    SUPABASE_URL.includes('example') ||
    SUPABASE_URL.includes('placeholder')
  )) {
    errors.push('VITE_SUPABASE_URL contains placeholder value. You need to set your REAL Supabase project URL.');
  }

  if (SUPABASE_ANON_KEY && (
    SUPABASE_ANON_KEY.includes('your-anon') ||
    SUPABASE_ANON_KEY === 'your-anon-public-key-here' ||
    SUPABASE_ANON_KEY.includes('example') ||
    SUPABASE_ANON_KEY.includes('placeholder') ||
    SUPABASE_ANON_KEY.length < 100 // Real JWT tokens are much longer
  )) {
    errors.push('VITE_SUPABASE_ANON_KEY contains placeholder value. You need to set your REAL Supabase anon key.');
  }

  return { isValid: errors.length === 0, errors };
}

const validation = validateSupabaseConfig();

const shouldUseMockSupabase = shouldForceMockSupabase || !validation.isValid;

if (!validation.isValid) {
  console.warn('[Supabase] Missing/placeholder configuration detected. Falling back to mock client:', validation.errors);
}

// SSR-safe storage adapter
// Prevents crashes when localStorage is not available (SSR, tests)
function getStorageAdapter() {
  // Check if we're in a browser environment with localStorage
  if (typeof window !== 'undefined' && window.localStorage) {
    return localStorage;
  }

  // Fallback: in-memory storage for SSR/test environments
  // This prevents crashes but sessions won't persist (which is fine for SSR/tests)
  const memoryStorage: Storage = {
    getItem: () => null,
    setItem: () => {},
    removeItem: () => {},
    clear: () => {},
    key: () => null,
    length: 0,
  };

  return memoryStorage;
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

function createMockSupabaseClient() {
  const mockUser = {
    id: 'ci-user',
    email: 'ci-user@example.com',
    user_metadata: {},
    app_metadata: {},
    aud: 'authenticated',
  } as unknown as User;

  const mockSession = {
    access_token: 'ci-mock-access-token',
    token_type: 'bearer',
    user: mockUser,
    expires_in: 3600,
    expires_at: Math.floor(Date.now() / 1000) + 3600,
  } as unknown as Session;

  const buildQueryBuilder = (mockData: unknown = null) => {
    const builder: any = {
      select: () => builder,
      insert: () => builder,
      update: () => builder,
      upsert: () => builder,
      delete: () => builder,
      eq: () => builder,
      neq: () => builder,
      gte: () => builder,
      lte: () => builder,
      like: () => builder,
      ilike: () => builder,
      contains: () => builder,
      textSearch: () => builder,
      order: () => builder,
      limit: () => builder,
      range: () => builder,
      throwOnError: () => builder,
      single: async () => ({ data: Array.isArray(mockData) ? mockData[0] ?? null : mockData, error: null }),
      maybeSingle: async () => ({ data: Array.isArray(mockData) ? mockData[0] ?? null : mockData, error: null }),
      returns: async () => ({ data: mockData ?? [], error: null }),
    };

    builder.then = (resolve: (value: unknown) => unknown, reject?: (reason?: unknown) => unknown) =>
      Promise.resolve({ data: mockData ?? [], error: null }).then(resolve, reject);

    return builder;
  };

  const createMockStorageBucket = (bucket: string) => ({
    upload: async (path: string) => ({ data: { path: `${bucket}/${path}` }, error: null }),
    getPublicUrl: (path: string) => {
      const publicUrl = `https://mock.supabase.local/storage/${bucket}/${path}`;
      return { data: { publicUrl }, error: null, publicUrl };
    },
    remove: async () => ({ data: null, error: null }),
    list: async () => ({ data: [], error: null }),
  });

  const mockAuth = {
    getSession: async () => ({ data: { session: mockSession }, error: null }),
    onAuthStateChange: (callback: (event: string, session: Session | null) => void) => {
      const subscription = { unsubscribe: () => {} };
      // Immediately inform listeners that we're "signed in" for deterministic CI/e2e flows
      try {
        callback('SIGNED_IN', mockSession);
      } catch (err) {
        console.error('Mock Supabase onAuthStateChange callback error:', err);
      }
      return { data: { subscription }, error: null };
    },
    signInWithPassword: async () => ({ data: { user: mockUser, session: mockSession }, error: null }),
    signOut: async () => ({ error: null }),
    signUp: async () => ({ data: { user: mockUser, session: mockSession }, error: null }),
    resetPasswordForEmail: async () => ({ data: { user: mockUser }, error: null }),
    updateUser: async () => ({ data: { user: mockUser }, error: null }),
  };

  return {
    auth: mockAuth,
    from: () => buildQueryBuilder(),
    functions: {
      invoke: async (_fn: string, options?: { body?: unknown }) => ({
        data: options?.body ?? { ok: true },
        error: null,
      }),
    },
    storage: {
      from: (bucket: string) => createMockStorageBucket(bucket),
    },
    rpc: async () => ({ data: null, error: null }),
  } as unknown as ReturnType<typeof createClient<Database>>;
}

if (shouldUseMockSupabase) {
  console.warn('Using mock Supabase client for deterministic CI/test runs. No network calls will be made.');
}

export const supabase = shouldUseMockSupabase
  ? createMockSupabaseClient()
  : createClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY, {
    auth: {
      storage: getStorageAdapter(),
      persistSession: typeof window !== 'undefined', // Only persist in browser
      autoRefreshToken: typeof window !== 'undefined', // Only auto-refresh in browser
    }
  }
  );

export const isSupabaseMocked = shouldUseMockSupabase;
