import { logger } from '@/lib/logger';
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

// Enhanced validation: detect missing AND placeholder values
function validateSupabaseConfig(): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];

  // Check if variables exist
  if (!SUPABASE_URL) {
    errors.push('VITE_SUPABASE_URL is not set');
  }
  if (!SUPABASE_ANON_KEY) {
    errors.push('VITE_SUPABASE_ANON_KEY is not set');
  }

  // Check for placeholder/dummy values
  if (SUPABASE_URL && (
    SUPABASE_URL.includes('your-project') ||
    SUPABASE_URL === 'https://your-project.supabase.co' ||
    SUPABASE_URL.includes('example') ||
    SUPABASE_URL.includes('placeholder')
  )) {
    errors.push('VITE_SUPABASE_URL contains placeholder value. You need to set your REAL Supabase project URL.');
  }

  if (SUPABASE_ANON_KEY && (
    SUPABASE_ANON_KEY.includes('your-anon') ||
    SUPABASE_ANON_KEY === 'your-anon-public-key-here' ||
    SUPABASE_ANON_KEY.includes('example') ||
    SUPABASE_ANON_KEY.includes('placeholder') ||
    SUPABASE_ANON_KEY.length < 100 // Real JWT tokens are much longer
  )) {
    errors.push('VITE_SUPABASE_ANON_KEY contains placeholder value. You need to set your REAL Supabase anon key.');
  }

  return { isValid: errors.length === 0, errors };
}

const validation = validateSupabaseConfig();

if (!validation.isValid && import.meta.env.MODE === 'production') {
  logger.error('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  logger.error('â•‘  âŒ SUPABASE CONFIGURATION ERROR                          â•‘');
  logger.error('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  logger.error('');
  logger.error('Your .env file contains placeholder/dummy values!');
  logger.error('');
  logger.error('Problems found:');
  validation.errors.forEach(err => logger.error(`  â€¢ ${err}`));
  logger.error('');
  logger.error('ðŸ“– HOW TO FIX:');
  logger.error('');
  logger.error('1. Go to https://supabase.com/dashboard');
  logger.error('2. Open your project (or create one if you don\'t have it)');
  logger.error('3. Go to Settings â†’ API');
  logger.error('4. Copy the following values:');
  logger.error('   â€¢ Project URL (starts with https://xxx.supabase.co)');
  logger.error('   â€¢ anon/public key (long JWT token starting with eyJ...)');
  logger.error('');
  logger.error('5. Update your .env file with REAL values:');
  logger.error('');
  logger.error('   VITE_SUPABASE_URL=https://YOUR-ACTUAL-PROJECT-ID.supabase.co');
  logger.error('   VITE_SUPABASE_ANON_KEY=eyJhbGci...YOUR-ACTUAL-KEY...');
  logger.error('');
  logger.error('6. Restart the dev server: npm run dev');
  logger.error('');
  logger.error('ðŸ“š For detailed setup instructions, see:');
  logger.error('   docs/SUPABASE_SETUP_GUIDE.md');
  logger.error('   docs/ENVIRONMENT_VARIABLES_CHECKLIST.md');
  logger.error('');

  throw new Error('Invalid Supabase configuration. See console for details.');
}

const mockSupabase = {
  auth: {
    onAuthStateChange: (_callback: unknown) => ({
      data: {
        subscription: { unsubscribe: () => {} },
      },
    }),
    getSession: async () => ({ data: { session: null }, error: null }),
    signInWithPassword: async () => ({ data: { user: null, session: null }, error: { message: 'Supabase not configured' } }),
    signUp: async () => ({ data: { user: null, session: null }, error: { message: 'Supabase not configured' } }),
    signOut: async () => ({ error: null }),
  },
  from: () => ({
    insert: async () => ({ data: null, error: null }),
  }),
} as const;

// SSR-safe storage adapter
// Prevents crashes when localStorage is not available (SSR, tests)
function getStorageAdapter() {
  // Check if we're in a browser environment with localStorage
  if (typeof window !== 'undefined' && window.localStorage) {
    return localStorage;
  }

  // Fallback: in-memory storage for SSR/test environments
  // This prevents crashes but sessions won't persist (which is fine for SSR/tests)
  const memoryStorage: Storage = {
    getItem: () => null,
    setItem: () => {},
    removeItem: () => {},
    clear: () => {},
    key: () => null,
    length: 0,
  };

  return memoryStorage;
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = validation.isValid
  ? createClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: {
        storage: getStorageAdapter(),
        persistSession: typeof window !== 'undefined', // Only persist in browser
        autoRefreshToken: typeof window !== 'undefined', // Only auto-refresh in browser
      }
    })
  : (mockSupabase as unknown as ReturnType<typeof createClient>);

/**
 * Health check for Supabase connectivity and essential tables
 * Returns status of connection and which tables are accessible
 */
export async function checkSupabaseHealth(): Promise<{
  isConnected: boolean;
  configurationValid: boolean;
  tablesAccessible: { [key: string]: boolean };
  errors: string[];
}> {
  const errors: string[] = [];
  const tablesAccessible: { [key: string]: boolean } = {};

  // Check configuration
  if (!validation.isValid) {
    errors.push('Supabase configuration is invalid');
    return {
      isConnected: false,
      configurationValid: false,
      tablesAccessible,
      errors
    };
  }

  // Try to connect and check essential tables
  const essentialTables = [
    'users',
    'user_roles',
    'team_members',
    'team_locations',
    'subcontractors',
    'projects',
    'quotes'
  ];

  for (const table of essentialTables) {
    try {
      const { error } = await supabase
        .from(table)
        .select('1')
        .limit(1);

      tablesAccessible[table] = !error;
      if (error) {
        errors.push(`Table '${table}' not accessible: ${error.message}`);
      }
    } catch (err) {
      tablesAccessible[table] = false;
      errors.push(`Table '${table}' check failed: ${err instanceof Error ? err.message : 'Unknown error'}`);
    }
  }

  const isConnected = Object.values(tablesAccessible).some(v => v);

  return {
    isConnected,
    configurationValid: validation.isValid,
    tablesAccessible,
    errors
  };
}
